syntax = "proto2";

package bsy;

enum Phase {
   TRAIN = 0;
   TEST = 1;
}


message DataBlockShape {
   repeated int64 dim = 1 [packed = true];
}

message DataBlockProto {
  optional DataBlockShape shape = 1;
  repeated float data = 2 [packed = true];
  repeated float diff = 3 [packed = true];
  repeated double double_data = 4 [packed = true];
  repeated double double_diff = 5 [packed = true];
}


message Datum {
  optional int32 channels = 1;
  optional int32 height = 2;
  optional int32 width = 3;
  // the actual image data, in bytes
  optional bytes data = 4;
  optional int32 label = 5;
  // Optionally, the datum could also hold float data.
  repeated float float_data = 6;
  // If true data contains an encoded image that need to be decoded
  optional bool encoded = 7 [default = false];
}

message DistributeGeneratorParameter {

  optional string type = 1 [default = 'constant'];
  optional float constant = 2 [default = 0]; // the value in constant filler
  optional float min = 3 [default = 0];
  optional float max = 4 [default = 1]; // the max value in uniform filler
  optional float mean = 5 [default = 0]; // the mean value in Gaussian filler
  optional float std = 6 [default = 1]; // the std value in Gaussian filler

  // The expected number of non-zero output weights for a given input in
  // Gaussian filler -- the default -1 means don't perform sparsification.
  optional int32 sparse = 7 [default = -1];
}

message TransformationParameter {
  // For data pre-processing, we can do simple scaling and subtracting the
  // data mean, if provided. Note that the mean subtraction is always carried
  // out before scaling.
  optional float scale = 1 [default = 1];
  // Specify if we want to randomly mirror data.
  optional bool mirror = 2 [default = false];
  // Specify if we would like to randomly crop an image.
  optional uint32 crop_size = 3 [default = 0];
  // mean_file and mean_value cannot be specified at the same time
  optional string mean_file = 4;
  // if specified can be repeated once (would subtract it from all the channels)
  // or can be repeated the same number of times as channels
  // (would subtract them from the corresponding channel)
  repeated float mean_value = 5;
  // Force the decoded image to have 3 color channels.
  optional bool force_color = 6 [default = false];
  // Force the decoded image to have 1 color channels.
  optional bool force_gray = 7 [default = false];
}
message  DataParam {
  enum DB {
    LEVELDB = 0;
  }

  // Specify the data source.
  optional string source = 1;
  // Specify the batch size.
  optional uint32 batch_size = 2;
  optional DB backend = 8 [default = LEVELDB];
  optional TransformationParameter transform_param = 9;

}

message LayerParameter {

  optional string name = 1; // the layer name
  optional string type = 2; // the layer type
  repeated string bottom = 3; // the name of each bottom DataBlockProto
  repeated string top = 4; // the name of each top DataBlockProto

  optional  Phase phase = 5;

  // The amount of weight to assign each top blob in the objective.
  // Each layer assigns a default value, usually of either 0 or 1,
  // to each top blob.
  repeated float loss_weight = 6;

  // The blobs containing the numeric parameters of the layer.
  repeated DataBlockProto data_blocks = 7;

  // Specifies whether to backpropagate to each bottom. If unspecified,
  // Bsy will automatically infer whether each input needs backpropagation
  // to compute parameter gradients. If set to true for some inputs,
  // backpropagation to those inputs is forced; if set false for some inputs,
  // backpropagation to those inputs is skipped.
  //
  // The size must be either 0 or equal to the number of bottoms.
  repeated bool propagate_down = 8;

}



